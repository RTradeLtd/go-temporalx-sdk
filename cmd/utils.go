package cmd

import (
	"encoding/hex"
	"errors"
	"fmt"
	"strings"

	nemonify "github.com/bonedaddy/nemonify"
	crypto "github.com/libp2p/go-libp2p-core/crypto"
	"github.com/libp2p/go-libp2p-core/peer"
	au "github.com/logrusorgru/aurora"
)

// createIPFSKey is a helper function to create an IPFS key
func createIPFSKey(keyType string, keySize int) (crypto.PrivKey, peer.ID, error) {
	var (
		pk  crypto.PrivKey
		err error
	)
	switch strings.ToLower(keyType) {
	case "rsa":
		pk, _, err = crypto.GenerateKeyPair(
			crypto.RSA,
			4096,
		)
	case "ed25519":
		pk, _, err = crypto.GenerateKeyPair(
			crypto.Ed25519,
			256,
		)
	case "ecdsa":
		pk, _, err = crypto.GenerateKeyPair(
			crypto.ECDSA,
			256,
		)
	case "secp256k1":
		pk, _, err = crypto.GenerateKeyPair(crypto.Secp256k1, 256)
	default:
		err = errors.New("key.type flag is empty or contains incorrect value")
	}
	if err != nil {
		return nil, "", err
	}
	pid, err := peer.IDFromPrivateKey(pk)
	if err != nil {
		return nil, "", err
	}
	return pk, pid, nil
}

// hexToKey is used to take a hex encoded string, converting it to a private key
func hexToKey(encoded string) (crypto.PrivKey, error) {
	decoded, err := hex.DecodeString(encoded)
	if err != nil {
		return nil, err
	}
	return crypto.UnmarshalPrivateKey(decoded)
}

// returns a key from a mnemonic phrase generated by this library
func keyFromMnemonic(msg string) (crypto.PrivKey, error) {
	unphrased, err := nemonify.FromMnemonic(msg)
	if err != nil {
		return nil, err
	}
	return crypto.UnmarshalPrivateKey([]byte(unphrased))
}

// short hand for printing out success results to stdout
// requires a slice and a 2 element array
func print(fmtStr string, args [][2]interface{}) {
	var parts []interface{}
	for _, pair := range args {
		parts = append(parts, au.Bold(au.Green(pair[0])), au.Bold(au.White(pair[1])))
	}
	fmt.Printf(
		fmtStr,
		parts...,
	)
}

// takes input and formats according to how print expects
func getArgs(args ...interface{}) (ret [][2]interface{}) {
	if len(args)%2 != 0 {
		panic("bad args")
	}
	for i := 0; i < len(args); i += 2 {
		var arg [2]interface{}
		arg[0] = args[i]
		arg[1] = args[i+1]
		ret = append(ret, arg)
	}
	return
}
